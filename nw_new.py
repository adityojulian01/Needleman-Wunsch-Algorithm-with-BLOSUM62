# -*- coding: utf-8 -*-
"""NW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11umZX8-oom1uhfZTzouFcXtsaAbWm9nu
"""

!pip install Bio

# Scoring two sequences based on BLOSUM62 matrix
# Use library for BLOSUM62 matrix
from Bio.SubsMat import MatrixInfo

# Return score between pair of two alignments (e.g 'A','B') and BLOSUM62 pair
def score_match(pair, matrix):
    if pair not in matrix:
        return matrix[(tuple(reversed(pair)))] # In case the alignments pair is reversed
    else:
        return matrix[pair]

#  Determine pair of two alignments whether both are equal/different/gap and also calculate its score
def score_pairwise(seq1, seq2, matrix, gap_s, gap_e):
    score = 0
    gap = False
    for i in range(len(seq1)):
        pair = (seq1[i], seq2[i])
        if not gap:
            if '-' in pair:
                gap = True
                score += gap_s
            else:
                score += score_match(pair, matrix)
        else:
            if '-' not in pair:
                gap = False
                score += score_match(pair, matrix)
            else:
                score += gap_e
    print('BLOSUM62 Score: ', end='')
    return score

# Assign align1 (final alignment after N-W algorithm) and align2 into seq1 and seq2
seq1 = align1
seq2 = align2

# Assign BLOSUM62 matrix into blosum variable
blosum = MatrixInfo.blosum62

# Importing Modules
import numpy as np

# Input Sequence
sequence_1 = "NALMSQA" # As shown in class
sequence_2 = "MNALQM" # As shown in class

# Create Matrices
default_matrix = np.zeros((len(sequence_1) + 1,len(sequence_2) + 1)) # Default Matrix
blosum_score = np.zeros((len(sequence_1),len(sequence_2))) # Blosum Matrix Default

# Display Main Matrix (example)
print('Initial Matrix: ', len(sequence_2) + 1, ' x ', len(sequence_1) + 1)
print(default_matrix)

# Insert the value of BLOSUM62 score between sequence_1 and sequance_2
for i in range(len(sequence_1)):
    for j in range(len(sequence_2)):
        blosum_score[i,j] = score_match((sequence_1[i],sequence_2[j]),blosum)

# Display BLOSUM62 score between sequence_1 and sequance_2 (example)
print('\n')
print('BLOSUM62 Score: ')
print(blosum_score)

# Providing the scores for gap
gap_penalty = -6

# Filling up the matrix using Needleman Wunsch algorithm
# 1: Filling the gap penalties
for i in range(len(sequence_1) + 1):
    default_matrix[i][0] = i * gap_penalty
for j in range(len(sequence_2) + 1):
    default_matrix[0][j] = j * gap_penalty

print('\nGap Penalties added: \n', default_matrix)

# 2: Matrix scoring
for i in range(1, len(sequence_1) + 1):
    for j in range(1, len(sequence_2) + 1):
        default_matrix[i][j] = max(default_matrix[i-1][j-1] + blosum_score[i-1][j-1],  # Diagonal
                                default_matrix[i-1][j] + gap_penalty,                  # Vertical
                                default_matrix[i][j-1] + gap_penalty)                  # Horizontal

print('\n')
print('Main Matrix after adding gap and BLOSUM62 matrix: ')
print(default_matrix)

# 3: Traceback and complete the alignment
# Assign variables to store alignment
align1 = ""
align2 = ""

# Start from the bottom right cell in matrix
i = len(sequence_1)
j = len(sequence_2)

# Using i and j to keep track of where we are in the matrix
while i > 0 and j > 0: # end touching the top or the left edge
    current_score = default_matrix[i][j]
    diagonal_score = default_matrix[i-1][j-1]
    up_score = default_matrix[i-1][j]
    left_score = default_matrix[i][j-1]
    
    # Check to figure out which cell the current score was calculated from,
    # then update i and j to correspond to that cell.
    if current_score == diagonal_score +  blosum_score[i-1][j-1]:
        align1 += sequence_1[i-1]
        align2 += sequence_2[j-1]
        i -= 1
        j -= 1
    elif current_score == up_score + gap_penalty:
        align1 += sequence_1[i-1]
        align2 += '-'
        i -= 1
    elif current_score == left_score + gap_penalty:
        align1 += '-'
        align2 += sequence_2[j-1]
        j -= 1

# Finalizing tracing up to the top left cell
while i > 0:
    align1 += sequence_1[i-1]
    align2 += '-'
    i -= 1
while j > 0:
    align1 += '-'
    align2 += sequence_2[-1]
    j -= 1

# Since we traversed the score matrix from the bottom right, our two sequences will be reversed.
# These two lines reverse the order of the characters in each sequence.
align1 = align1[::-1]
align2 = align2[::-1]

# Display final alignment after N-W algorithm
print('\nFinal Alignment: ')
print(align1)
print(align2,'\n')
score_pairwise(seq1, seq2, blosum, -6, -6)